# Базы данных (SQL)

# Работа в приложении DBeaver и Postgresql(реляционная база данных).
# Так же их нужно будет связать между собой через DBeaver

""" Команды в SQL:


    SHOW
    Эта команда предназначена для просмотра доступных баз данных и таблиц в конкретных базах данных. Для просмотра списка баз данных необходимо ввести такую команду:

    SHOW DATABASES;
    Если, например, существуют две базы данных - mysql и test (эти две базы, как правило, создаются автоматически при инсталляции сервера), то MySQL ответит примерно так:

                                                                            +----------+
                                                                            | Database |
                                                                            +----------+
                                                                            | mysql    |
                                                                            | test     |
                                                                            +----------+
    Для просмотра списка таблиц используется эта же команда в таком виде:

    SHOW TABLES;
    Эта команда выдаст список таблиц в текущей базе данных:

                                                                        +-----------------+
                                                                        | Tables in mysql |
                                                                        +-----------------+
                                                                        | test            |
                                                                        | mysql           |
                                                                        +-----------------+

    Замечание: вы можете работать только с одной базой данных в одно и то же время, поэтому в приведенном выше примере нет нужды указывать название базы данных, список таблиц которой стоит вывести,
    поскольку производится поиск в активной на данный момент базе.


    CREATE
    Эта команда позволяет создавать новые базы данных. Как было сказано выше, по умолчанию сервер создает две базы данных - mysql и test. Для удобства стоит создавать новую базу данных для каждой
    отдельной задачи, потому что легче работать с набором таблиц, которые связаны между собой (даже если эта связь только смысловая). Создадим новую базу данных при помощи этой команды:

    CREATE DATABASE staff

    После этой операции будет создана новая база данных не содержащая никаких таблиц, а команда SHOW DATABASES выдаст следующее:

                                                                            +----------+
                                                                            | Database |
                                                                            +----------+
                                                                            | mysql    |
                                                                            | test     |
                                                                            | staff    |
                                                                            +----------+


    USE
    Как уже было сказано выше, в один и тот же момент только одна база данных может быть активна. Команда USE служит для выбора этой активной базы. Для перехода к некоторой базе данных необходимо
    выполнить следующую операцию:

    USE staff

    Стоит отметить, что при создании новой базы данных (см. выше), новая база не становится активной автоматически - для ее использования необходимо сделать это самостоятельно.


    Наипростейшей командой является следующая:

    SELECT * FROM mysql;

    Эта команда подразумевает, что в активной базе данных существует таблица mysql, из которой она просто извлекает все данные и выводит их на экран.

    Замечание: На SQL-команды распространяется одно ограничение, которое не имеет отношения к командам MySQL - инструкции SQL обязательно должны заканчиваться точкой с запятой.
    Это позволяет вводить многострочные запросы к базе данных, что не требуется для MySQL-команд, которые, как правило, лаконичные и короткие.
    Как вы уже наверное поняли, команда SELECT служит для просмотра данных таблиц. Ее упрощенный синтаксис таков:

    SELECT <список полей> FROM <список названий таблиц> [WHERE <список условий>]

    Первая строка велит MySQL показать содержимое только полей name, project и works_since. Вторая строка указывает на таблицу, в которой следует искать эти данные.
    Оставшаяся часть запроса указывает критерии выбора - имя не должно быть 'Иван', а дата быть более ранней, чем 26-е апреля 1998-го года. Вот пример вывода после такой операции:

                                                                +----------+--------------+-------------+
                                                                | name     | project      | works_since |
                                                                +----------+--------------+-------------+
                                                                | Fred     | Secret data  | 1997-01-01  |
                                                                | Jonathan | Blue apples  | 1997-06-01  |
                                                                +----------+--------------+-------------+

    Для показа данных одного поля может использоваться такой запрос:

    SELECT project FROM staff ORDER BY project;

                                                                            +-------------+
                                                                            | project     |
                                                                            +-------------+
                                                                            | Blue apples |
                                                                            | Blue apples |
                                                                            | Cornichons  |
                                                                            | Secret data |
                                                                            | Secret data |
                                                                            | Secret data |
                                                                            +-------------+

    Как видите, этот запрос просто выбирает значения из нужного поля из каждой строки и выводит их, заодно сортируя по (единственному) полю project, поэтому в результатах встречаются повторения.
    Для устранения их используется инструкция DISTINCT:


    SELECT DISTINCT project FROM staff ORDER BY project;

                                                                            +-------------+
                                                                            | project     |
                                                                            +-------------+
                                                                            | Blue apples |
                                                                            | Cornichons  |
                                                                            | Secret data |
                                                                            +-------------+

    SQL позволяет производить некоторые вычисления и получать некоторую описательную информацию при помощи агрегатных функций. Среди этих функций - COUNT, SUM, MAX, MIN и AVG:

    COUNT - вычисляет количество найденных строк;
    SUM - находит сумму значений в найденных строках;
    MAX - находит наибольшее среди найденных значений;
    MIN - находит наименьшее среди найденных значений;
    AVG - находит среднее значение от найденных.

    Используются эти функции как элементы списка таблиц в запросе с аргументом - названием поля. Вот несколько примеров.

    SELECT COUNT (project) FROM staff;
    SELECT MAX (projects_done) FROM staff;
    SELECT AVG (project_done) FROM staff;


    LIKE
    Оператор LIKE используется в WHERE, чтобы задать шаблон поиска похожего значения.

    _ — Подчеркнутый символ представляет собой один символ.
    % — Знак процента представляет нулевой, один или несколько символов.
    WHERE name LIKE ‘text%’ : Находит любые значения, начинающиеся с «text».
    WHERE name LIKE ‘%text’ : Находит любые значения, заканчивающиеся на «text».
    WHERE name LIKE ‘%text%’ : Находит любые значения, которые имеют «text» в любой позиции.
    WHERE name LIKE ‘_text%’ : Находит любые значения, которые имеют «text» во второй позиции.
    WHERE name LIKE ‘text_%_%’ : Находит любые значения, начинающиеся с «text» и длиной не менее 3 символов.
    WHERE name LIKE ‘text%data’ : Находит любые значения, начинающиеся с «text» и заканчивающиеся на «data».

    Для сравнения значения с регулярным выражением используется оператор LIKE, а для конструирования простейших выражений - символы '_' (произвольный символ) и '%'
    (произвольное количество произвольных символов).
    Пример. Этот запрос находит все имена, которые начинаются с 'Jo':

    SELECT name FROM staff
    WHERE name LIKE 'Jo%n';

                                                                                +----------+
                                                                                | name     |
                                                                                +----------+
                                                                                | Jonathan |
                                                                                | John     |
                                                                                +----------+


    Редактирование данных

    Редактирование данных - это добавление, удаление и изменение их. Для выполнения этих операций используются команды INSERT, DELETE и UPDATE соответственно.

    Команда INSERT служит для вставки строк в таблицы. Вот как может выглядеть такой запрос:

    INSERT INTO staff VALUES ("Robert", "1980-05-07", "2000-04-26",
    "$100", "Secret data");

    Возможна также вставка отдельных значений. В таком случае необходимо указать, в какие поля стоит вставлять данные, причем оставшиеся поля будут незаполнены - при выполнении
    запросов SELECT они будут представлены как NULL - специальное значение, означающее, что данное отсутствует.

    INSERT INTO staff(name, date_of_birth) VALUES ("Jack", "1977-07-29");

    SELECT * FROM staff
    WHERE name = "Jack";

                                                            +------+---------------+-------------+---------+---------+
                                                            | name | date_of_birth | works_since | project | sallary |
                                                            +------+---------------+-------------+---------+---------+
                                                            | Jack | 1997-07-29    | NULL        | NULL    | NULL    |
                                                            +------+---------------+-------------+---------+---------+

    Удаление данных производится командой DELETE. Для этого нужно указать таблицу и (необязательно) условия, в которых должны удовлетворять строки, которые следует удалить.
    Если условия опущены, эта команда, как и SELECT, проделает эту операцию надо всеми строками - то есть очистит таблицу.

    DELETE FROM staff
    WHERE
    name = "Jack";

    Изменение данных производится при помощи команды UPDATE. Необходимо указать, значения каких полей следует изменить, а также (опять же необязательно) условия, которым должны удовлетворять строки,
    которые следует обновить.

    UPDATE staff
    SET
    works_since = "2000-04-26"
    sallary = "$200"
    project = "Secret data"
    WHERE
    name = "Jack";

    Этот запрос устанавливает дату принятия на работу, зарплату и название проекта всем Джекам, которые находятся в базе данных.


    Практика на сайте https://www.w3schools.com/sql/trysql.asp?filename=trysql_asc:

    Вывод информации:

    SELECT * FROM Customers; - команда для вывода всей информации о покупателях;
    SELECT * FROM Customers WHERE ContactName = 'Maria Larsson'; - команда для вывода информации о конкретном покупателе;
    SELECT * FROM Customers WHERE CustomerID = 23; - команда для вывода информации по ID;
    SELECT * FROM Customers WHERE Country = 'USA'; - команда для вывода информации по стране;

    Поиск информации:

    SELECT * FROM Customers WHERE CustomerName LIKE "%app'" - команда для поиска имени клиента оканчивающегося на "app'";
    SELECT * FROM Customers WHERE CustomerName LIKE 'Die%'; - команда для поиска имени клиента начинающаяся на 'Die';
    SELECT * FROM Customers WHERE ContactName LIKE '%ev%'; - команда для поиска контактного имени клиента с частичным буквами 'ev';

    Редактирование информации:

    UPDATE Customers SET City = 'Boston'; - замена всей информации в столбце City на 'Boston';
    UPDATE Customers SET City = 'Minsk' WHERE CustomerID = 5; - замена информации в столбце City на 'Minsk' для клиента с ID 5;

    P.S. команды выполняются без вывода информации, используем:

    SELECT * FROM Customers; - информация выведется с изменениями;

    Вставка полной или частичной информации(строка):

    INSERT INTO Customers (CustomerID, CustomerName, ContactName, Address, City, PostalCode, Country ) VALUES (92, 'SloWmo', 'Alex Vinokurov', 'Matrosova 39', 'Orsha', '211390', 'Belarus'); - вставка всех  данных в строку;
    INSERT INTO Customers (CustomerID, ContactName, City, Country ) VALUES (93, 'Alex Vinokurov', 'Orsha', 'Belarus'); - вставка частичных данных в строку, пустые поля примут значение	null;

    P.S. команды выполняются без вывода информации, используем:

    SELECT * FROM Customers; - информация выведется с изменениями;


    Прочее:

    -- - в SQL это обозначение комментария как в Python #


1) Связь один к одному в SQL:
    Данный тип связей встречает нечасто. В этом случае объекту одной сущности можно сопоставить только один объект другой сущности. Например, на некоторых сайтах пользователь может иметь только один блог.
То есть возникает отношение один пользователь - один блог. Нередко этот тип связей предполагает разбиение одной большой таблицы на несколько маленьких. Основная родительская таблица в этом случае продолжает
содержать часто используемые данные, а дочерняя зависимая таблица обычно хранит данные, которые используются реже. В этом отношении первичный ключ зависимой таблицы в то же время является внешним ключом,
который ссылается на первичный ключ из главной таблицы.
Например, таблица Users представляет пользователей и имеет следующие столбцы:

- UserId (идентификатор, первичный ключ)

- Name (имя пользователя)

И таблица Blogs представляет блоги пользователей и имеет следующие столбцы:

- BlogId (идентификатор, первичный и внешний ключ)

- Name (название блога)

В этом случае столбец BlogId будет хранить значение из столбца UserId из таблицы пользователей. То есть столбец BlogId будет выступать одновременно первичным и внешним ключом.

                                                                            +----------+
                                                                            |  Users   |
                                                                            +----------+
                                                                            | ъ user   |
                                                                            |   name   |
                                                                            +----------+
                                                                                 |
                                                                                 |
                                                                                 Ъ
                                                                            +----------+
                                                                            |  Blogs   |
                                                                            +----------+
                                                                            | ъ blogId |
                                                                            |   name   |
                                                                            +----------+            ъ(Ъ) - ключ(key)

2) Связь один ко многим в SQL:
    Это наиболее часто встречаемый тип связей. В этом типе связей несколько строк из дочерний таблицы зависят от одной строки в родительской таблице. Например, в одном блоге может быть несколько статей.
В этом случае таблица блогов является родительской, а таблица статей - дочерней. То есть один блог - много статей. Или другой пример, в футбольной команде может играть несколько футболистов.
И в то же время один футболист одновременно может играть только в одной команде. То есть одна команда - много футболистов. К примеру, пусть будет таблица Articles, которая представляет статьи блога и
которая имеет следующие столбцы:

ArticleId (идентификатор, первичный ключ)

BlogId (внешний ключ)

Title (название статьи)

Text (текст статьи)

В этом случае столбец BlogId из таблицы статей будет хранить значение из столбца BlogId из таблицы блогов.

                                                                            +------------+
                                                                            |  Articles  |
                                                                            +------------+
                                                                            |ъ ArticleId |
                                                                            |   Title    |
                                                                            |    Text    |
                                                                            |   BlogId   |
                                                                            +------------+
                                                                                  Ъ
                                                                                  |
                                                                                  |
                                                                                  Ъ
                                                                             +----------+
                                                                             |  Blogs   |
                                                                             +----------+
                                                                             | ъ blogId |
                                                                             |   name   |
                                                                             +----------+           ъ(Ъ) - ключ(key)

3) Связь многие ко многим в SQL:

Связь многие ко многим
При этом типе связей одна строка из таблицы А может быть связана с множеством строк из таблицы В. В свою очередь одна строка из таблицы В может быть связана с множеством строк из таблицы А.
Типичный пример - студенты и курсы: один студент может посещать несколько курсов, и соответственно на один курс могут записаться несколько студентов. Другой пример - статьи и теги: для одной статьи можно
определить несколько тегов, а один тег может быть определен для нескольких статей. Но в SQL Server на уровне базы данных мы не можем установить прямую связь многие ко многим между двумя таблицами.
Это делается посредством вспомогательной промежуточной таблицы. Иногда данные из этой промежуточной таблицы представляют отдельную сущность.

Например, в случае со статьями и тегами пусть будет таблица Tags, которая имеет два столбца:

TagId (идентификатор, первичный ключ)

Text (текст тега)

Также пусть будет промежуточная таблица ArticleTags со следующими полями:

TagId (идентификатор, первичный и внешний ключ)

ArticleIdId (идентификатор, первичный и внешний ключ)

                                                                            +------------+
                                                                            |  Articles  |
                                                                            +------------+
                                                                            |ъ ArticleId |
                                                                            |   Title    |
                                                                            |    Text    |
                                                                            |   BlogId   |
                                                                            +------------+
                                                                                  Ъ
                                                                                  |
                                                                                  |
                                                                            +-------------+
                                                                            | ArticleTags |
                                                                            +-------------+
                                                                            | ъ ArticleId |
                                                                            | ъ  TagId    |
                                                                            +-------------+
                                                                                  |
                                                                                  |
                                                                                  Ъ
                                                                            +-------------+
                                                                            |    Tags     |
                                                                            +-------------+
                                                                            | ъ  TagId    |
                                                                            |    Text     |
                                                                            +-------------+             ъ(Ъ) - ключ(key)

Технически мы получим две связи один-ко-многим. Столбец TagId из таблицы ArticleTags будет ссылаться на столбец TagId из таблицы Tags. А столбец ArticleId из таблицы ArticleTags будет ссылаться на
столбец ArticleId из таблицы Articles. То есть столбцы TagId и ArticleId в таблице ArticleTags представляют составной первичный ключ и одновременно являются внешними ключами для связи с таблицами
Articles и Tags. """

